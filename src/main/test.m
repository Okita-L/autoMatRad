projectPath = 'E:\workShop\autoMatRad'; 
addpath(genpath(projectPath));

matRad_rc;
auto_rc;
% 禁用GUI
matRad_cfg = MatRad_Config.instance();
matRad_cfg.disableGUI = true;
processor = autoProcessor(projectPath);

load('C:\Users\Administrator\Desktop\DIJ\14-PT3236730_dij.mat');
load('E:\Workshop\autoMatRad\data\STFMat_data\14-PT3236730_Stf.mat');
load('E:\Workshop\autoMatRad\data\CSTMat_data\14-PT3236730.mat');
new_cst = matRad_resizeCstToGrid(cst,dij.ctGrid.x,dij.ctGrid.y,dij.ctGrid.z,...
            dij.doseGrid.x,dij.doseGrid.y,dij.doseGrid.z);
load('C:\Users\Administrator\Desktop\resultGUI\14-PT3236730_resultGUI.mat');
ID = '14-PT3236730';
origin = Determine_origin(new_cst, dij, stf, dij, resultGUI, ID)

%% test getALLOrgCSV(obj, cst, ct, stf, pln, dij, resultGUI, fileName, path_of_OrgCSV)
% % 开启并行池
% currenrPool = gcp('nocreate');
% if isempty(currenrPool)
%     disp('没有找到活动的并行池，正在启动...');
%     p = parpool;
% else
%     disp(['已找到活动的并行池，包含 ', num2str(currentPool.NumWorkers), ' 个工作进程。']);
%     p = currentPool;
% end
% load('C:\Users\Administrator\Desktop\DIJ\14-PT3236730_dij.mat');
% load('C:\Users\Administrator\Desktop\resultGUI\14-PT3236730_resultGUI.mat');
% load('C:\Users\Administrator\Desktop\14-PT3236730.mat');
% load('C:\Users\Administrator\Desktop\14-PT3236730_stf.mat')
% processor.getALLOrgCSV(cst,ct,stf,pln,dij,resultGUI,'14-PT3236730', 'C:\Users\Administrator\Desktop\OrgCSV_file');

% % 关闭并行池
% p = gcp; 
% if ~isempty(p)
%     delete(p);
%     disp('并行池已关闭。');
% end


%% test autoGenerateDIJ
% processor.autoGenerateDIJandResultGUI();


%% test autoGenerateSTF
% autoGenerateSTF('C:\Users\Administrator\Desktop\old','C:\Users\Administrator\Desktop');

%% test autoProcessCST(obj, OARs, Targets, path_of_rawMat, path_of_CSTMat)
% % all passed
% % but noticed that if u want to declare a variable as cell array
% % u should let the stupid matlab know that declaration before u using it
% load('E:\Workshop\autoMatRad\data\mat_data\1-PT3113820.mat','cst','-mat');
% % constraintOfTarget
% constraintOfTarget1.className = 'DoseObjectives.matRad_SquaredDeviation';
% constraintOfTarget1.parameters = {}; % 否则matlab不知道这是一个元胞数组
% constraintOfTarget1.parameters{1} = 30;
% constraintOfTarget1.penalty = 800;
% % constrainOfOARs
% constraint.className = 'DoseObjectives.matRad_SquaredOverdosing';
% constraint.parameters={};
% constraint.parameters{1} = 54;
% constraint.penalty = 300;
% % constraintOfParotid
% constraintOfParotid1.className = constraint.className;
% constraintOfParotid1.parameters={};
% constraintOfParotid1.parameters{1} = 28;
% constraintOfParotid1.penalty = 300;
% % constraintOfBody
% constraintOfBody1.className = constraint.className;
% constraintOfBody1.parameters = {};
% constraintOfBody1.parameters{1} = 55;
% constraintOfBody1.penalty = 300;
% 
% Targets = {["ctv1", "ctv", "ctv2"], [constraintOfTarget1]};
% OARs = {["body", "body1", "body3"],[constraintOfBody1];
%     ["brainstem"],[constraint];
%     ["opticnerve l"],[constraint];
%     ["opticnerve r"],[constraint];
%     ["opticchiasm","chiasm"],[constraint];
%     ["parotid r"],[constraintOfParotid1];
%     ["parotid l"],[constraintOfParotid1];
%     }
% path_of_rawMat = 'E:\Workshop\autoMatRad\data\mat_data';
% path_of_CSTMat = 'C:\Users\Administrator\Desktop'
% processor.autoProcessCST(OARs,Targets, path_of_rawMat,path_of_CSTMat);


%% getTargeIndices and oarsIndices
% test getTargeIndices and oarsIndices. all passed
% 
% load('E:\Workshop\autoMatRad\data\mat_data\1-PT3113820.mat','cst','-mat');
% Targets1col = {["body","body1","body3"],[cst{43,6}{1,1}];
%     ["opticchiasm","chiasm"], [cst{43,6}{1,1}];
%     ["ctv1","ctv2"], [cst{43,6}{1,1}];
%     } % 如果 '' 就无法识别 因为 [] 的串联行为
% cstSubset= cst(:, 2);
% Targets1col = Targets1col(:,1);
% 
% Index = processor.getTargetIndex(Targets1col,cstSubset);
% idx = processor.getOARsIndices(Targets1col,cstSubset);

%% autoLoadDicom
% autoLoadDicomSigle Pass!
% processor.autoLoadDicomSigle('D:\workShop\autoMatRad\data\dicom_data\test\1-PT3113820');

% autoLoadDicomBatch Pass!
% processor.autoLoadDicomBatch('D:\workShop\autoMatRad\data\dicom_data\test')



%% 
% 1-PT3113820.mat
% 2-PT3112469.mat
% 8-PT3186851.mat

% old = load('C:\Users\Administrator\Desktop\old\same\44-PT3290956a.mat');
% new = load('E:\Workshop\autoMatRad\data\CSTMat_data\44-PT3290956a.mat');
% 
% old_stf = load('C:\Users\Administrator\Desktop\old\same_STF\44-PT3290956a_Stf.mat');
% new_stf = load('E:\Workshop\autoMatRad\data\STFMat_data\8-PT3186851_Stf.mat');
% 

% %% 
% constraintOfTarget1.className = 'DoseObjectives.matRad_SquaredDeviation';
% constraintOfTarget1.parameters = {}; % 否则matlab不知道这是一个元胞数组
% constraintOfTarget1.parameters{1} = 30;
% constraintOfTarget1.penalty = 800;


%% 检查ct是否一致
% % 假设已经加载了 ct1 和 ct2 结构体
% % 提取 HU 数组
% old = load('C:\Users\Administrator\Desktop\old\8-PT3186851.mat');
% new = load('E:\Workshop\autoMatRad\data\CSTMat_data\8-PT3186851.mat');
% 
% % 检查 resolution 字段
% if ~isequal(old.ct.resolution, new.ct.resolution)
%     fprintf('Warning: ct.resolution is different.\n');
% end
% 
% % 检查 x 字段
% if ~isequal(old.ct.x, new.ct.x)
%     fprintf('Warning: ct.x (X-coordinates) is different.\n');
% end
% 
% % 检查 y 字段
% if ~isequal(old.ct.y, new.ct.y)
%     fprintf('Warning: ct.y (Y-coordinates) is different.\n');
% end
% 
% % 检查 z 字段
% if ~isequal(old.ct.z, new.ct.z)
%     fprintf('Warning: ct.z (Z-coordinates) is different.\n');
% end
% 
% % 检查 cubeDim 字段
% if ~isequal(old.ct.cubeDim, new.ct.cubeDim)
%     fprintf('Warning: ct.cubeDim (Volume dimensions) is different.\n');
% end
% 
% % 检查 dicomInfo 字段
% if ~isequal(old.ct.dicomInfo, new.ct.dicomInfo)
%     fprintf('Warning: ct.dicomInfo (DICOM metadata) is different.\n');
% end
% 
% % 检查 dicomMeta 字段 仅仅是文件名不一样而已 没有实质区别
% if ~isequal(old.ct.dicomMeta, new.ct.dicomMeta)
%     fprintf('Warning: ct.dicomMeta 结构体存在差异。正在检查内部字段...\n');
%     try
%         meta_fields = fieldnames(old.ct.dicomMeta);
%     catch 
%         fprintf('Error: 无法获取 dicomMeta 字段名，可能结构体为空或不一致。\n');
%         return; % 退出检查
%     end
%     % 遍历 dicomMeta 中的每个字段
%     for i = 1:length(meta_fields)
%         fieldName = meta_fields{i};
% 
%         % 确保两个结构体都有这个字段，并进行比较
%         if isfield(new.ct.dicomMeta, fieldName)
%             if ~isequal(old.ct.dicomMeta.(fieldName), new.ct.dicomMeta.(fieldName))
%                 fprintf('  -> 差异位于：ct.dicomMeta.%s\n', fieldName);
%             end
%         else
%             % 如果 new 结构体缺少某个字段（虽然通常应该一致）
%             fprintf('  -> 警告：ct.dicomMeta.%s 在 new 结构体中缺失。\n', fieldName);
%         end
%     end
% end
% 
% hu_data1 = old.ct.cubeHU{1};
% hu_data2 = new.ct.cubeHU{1};
% 
% % 1. 检查数据类型和尺寸是否一致（这是 isequal 隐含做的）
% if ~isequal(size(hu_data1), size(hu_data2))
%     fprintf('警告: cubeHU 数组的尺寸不一致。\n');
% elseif ~isequal(class(hu_data1), class(hu_data2))
%     fprintf('警告: cubeHU 数组的数据类型不一致。\n');
% end
% 
% % 2. 使用 isequal 比较数组的每个元素
% if isequal(hu_data1, hu_data2)
%     fprintf('结论: 两份 ct 的 cubeHU 数组【完全一致】。\n');
% else
%     fprintf('结论: 两份 ct 的 cubeHU 数组【存在差异】。\n');
% 
%     % 可选：进一步查看差异信息
%     diff_mask = (hu_data1 ~= hu_data2);
%     num_diff_voxels = sum(diff_mask(:));
%     if num_diff_voxels > 0
%         fprintf('  - 不一致的体素数量: %d / %d\n', num_diff_voxels, numel(hu_data1));
% 
%         % 打印最大差异（绝对值）
%         max_diff = max(abs(hu_data1(diff_mask) - hu_data2(diff_mask)));
%         fprintf('  - HU 值的最大绝对差异: %.4f HU\n', max_diff);
%     end
% end

%% 检查cst是否一致
% TODO



%% 测试能否启用并行池
% 1. 尝试启动并行池
% try
%     % 启动并行池，或不启动 if 已经存在
%     if isempty(gcp('nocreate'))
%         disp('尝试启动并行池...');
%         parpool; 
%     end
% 
%     poolobj = gcp;
%     fprintf('当前并行池已启动，工作进程数：%d\n', poolobj.NumWorkers);
% 
%     % 2. 执行您的 DIJ 计算等任务
%     % ... 您的 matRad 循环代码 ...
% 
% finally
%     % 3. 确保清理，即使出错
%     delete(gcp('nocreate')); % 仅在存在时删除
%     disp('并行池已关闭。');
% end